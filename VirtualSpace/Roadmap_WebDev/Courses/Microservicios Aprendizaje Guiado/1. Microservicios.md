#Learning #Microservicios
## Fase 1 (la teoría)

### 1. Arquitectura de Microservicios:

Los Microservicios se cataloga como la arquitectura de una aplicación y que se compone de una colección de servicios débilmente acoplados, la ventaja clave de esta arquitectura  son la escalabilidad  independiente y la tolerancia a fallos.

### 2. Domain-Driven Design(DDD)

Los `Domain-Driven Design (DDD)`: son un enfoque de diseño de software que se basa en dos conceptos clave:

> **Objetivo:** Aprender a diseñar los límites de tus servicios de forma lógica, basándote en la lógica del negocio.

- `Bounded Context (Contexto Delimitado)` es la frontera lógica que divide un dominio de negocio en partes independientes, en pocas palabras le pone limites a un funcionalidad para que nos se pierda en funcionalidades mas grandes.

> **[Lectura Contexto Delimitado](https://martinfowler.com/bliki/BoundedContext.html) 


- `Lenguaje Ubico`: se refiere a manejar un vocabulario mas global al momento de contextualizar con el equipo como se manejara la nomenclatura del proyecto para evitar malentendidos.

> **[Lectura Lenguaje Ubico](https://gist.github.com/codewithleader/a847f587eb517fe79c2d874f5c365ded)

#### Lectura adicional

La fuente principal de DDD es [el libro de Eric Evans](https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321125215&linkCode=as2&tag=martinfowlerc-20) . No es la lectura más sencilla de la literatura de software, pero es uno de esos libros que compensa con creces una inversión sustancial. Bounded Context abre la parte IV (Diseño Estratégico).

[El libro "Implementación del Diseño Orientado al Dominio"](https://www.amazon.com/gp/product/0321834577/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321834577&linkCode=as2&tag=martinfowlerc-20) de Vaughn Vernon se centra en el diseño estratégico desde el principio. El capítulo 2 detalla cómo se divide un dominio en contextos delimitados, y el capítulo 3 es la mejor fuente para dibujar mapas de contexto.

[Verraes y Wirfs-Brock](https://verraes.net/2021/06/split-domain-across-bounded-contexts/) hablan sobre algunas de las sutilezas de delinear contextos delimitados, en particular cuando un contexto puede necesitar dividirse por razones que tienen tanto que ver con la historia y las relaciones humanas como con los conceptos de dominio.

Me encantan los libros de software, tanto antiguos como vigentes. Uno de mis favoritos es ["Datos y Realidad"](https://www.amazon.com/gp/product/1935504215/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1935504215&linkCode=as2&tag=martinfowlerc-20) de William Kent . Aún recuerdo su breve descripción del polisema de los pozos petrolíferos.

Eric Evans describe cómo el uso explícito de un contexto delimitado permite a los equipos integrar nuevas funcionalidades en sistemas heredados mediante un [contexto burbuja](http://domainlanguage.com/wp-content/uploads/2016/04/GettingStartedWithDDDWhenSurroundedByLegacySystemsV1.pdf) . El ejemplo ilustra cómo los contextos delimitados relacionados tienen modelos similares, pero distintos, y cómo se pueden mapear entre ellos.
## Fase 2 Herramientas Fundamentales (La Práctica)

### 1. Contenedores (Docker):

> **Objetivo:** Ser capaz de empaquetar tus aplicaciones en contenedores, que es la forma estándar de desplegar microservicios.

`Docker y contenedores:`
Docker es una plataforma que usa contenedores. **Un contenedor** es un paquete liviano y aislado que incluye todo lo que necesita una aplicación para funcionar.

`Dockerfile:` Se puede entender como una receta  que trae las instrucciones, para construir una imagen de Docker.

![[Dockerfile.png]]

``` docker
FROM python:3.9  
# Usa una imagen base con Python 3.9

WORKDIR /app
#Define el dirctorio de trabajo dentro del contenedor

COPY requirements.txt .
# Copia el archivo de dependencias al contenedor

RUN pip install -r requirements.txt
# Instala las dependencias listadas en el archivo

COPY . .
# Copia el resto de los archivos del proyecto al contenedor

CMD python app.py
# Define el comando para iniciar el servidor de Django
```

Para poder ejecutar nuestro aplicación necesitamos dos comandos  el primero construye la imagen con los archivos del proyecto:

```bash
docker build -t mi-django-app .
```

El comando tiene dos partes principales:

1. **`docker build -t`**: La parte `-t` significa "tag" (etiqueta) y te permite ponerle un nombre a tu imagen. Por ejemplo, podríamos llamarla `mi-django-app`.
    
2. **`.`**: El punto al final le dice a Docker que busque el `Dockerfile` en el directorio actual.

El otro comando es para ejecutar el contenedor

```bash
docker run -p 8000:8000 -it mi-django-app
```

El comando necesita tres cosas:

1. **`docker run -p 8000:8000`**: La parte `-p` (port) le dice a Docker que "mapee" un puerto del contenedor a un puerto de tu máquina. En este caso, el puerto `8000` del contenedor se mapeará al puerto `8000` de tu computadora.
    
2. **`-it`**: Estas opciones te permiten interactuar con el contenedor (para ver el log de Django, por ejemplo).
    
3. **`mi-django-app`**: El nombre de la imagen que acabas de construir.
#### `docker-compose`: 

### **¿Qué es Docker Compose?**

**Docker Compose** es una herramienta que te permite **definir y ejecutar aplicaciones multicontenedor** de Docker. En lugar de ejecutar un solo contenedor, como lo hicimos, Compose te ayuda a gestionar un conjunto de servicios que trabajan juntos.

### **¿Por qué es el siguiente paso?**

Hasta ahora, hemos ejecutado un solo contenedor para nuestra aplicación de Django. Pero en un escenario real, un backend como Django también necesitaría una **base de datos** (como PostgreSQL o MySQL), un **cache** (como Redis) o un **servidor web** (como Nginx).

Cada uno de estos componentes es un servicio que se puede ejecutar en su propio contenedor. Docker Compose resuelve el desafío de conectar todos estos contenedores entre sí.

### **El archivo `docker-compose.yml`**

El corazón de Docker Compose es el archivo **`docker-compose.yml`**. Este archivo es un "manual de instrucciones" escrito en YAML donde defines todos los servicios que componen tu aplicación, sus configuraciones, las redes que los conectan y cómo se comunican entre sí.

Con un solo comando (`docker-compose up`), puedes construir, lanzar y conectar todos los servicios que definas en ese archivo.

En nuestra carpeta de proyecto, debemos crear un archivo llamado `docker-compose.yml` este archivo contiene toda la información de los servicios a unir, por ejemplo si queremos trabajar con una base de datos, que se una a un despliegue de una aplicación de Flask.

El archivo pues contendrá la configuración de la base de datos y de la aplicación web, buscando la dependencia uno de otro. En nuestro caso la aplicación web depende de la base de datos.

![[docker-compose.yml.png]]

Cabe aclarar que el archivo `dockerfile`, sigue existiendo y este tendrá la configuración de la aplicación web con `Flask`.

Ahora, para poner todo en marcha, la magia de Docker Compose es que solo necesitas un único comando desde tu terminal, dentro de la carpeta del proyecto.

```bash
docker-compose up
```

Este comando:

- Lee el archivo `docker-compose.yml`.
    
- Construye la imagen del servicio `web`.
    
- Descarga la imagen de PostgreSQL para el servicio `db`.
    
- Lanza ambos contenedores, respetando la dependencia (`db` primero, luego `web`).

```bash
docker-compose down
```

Detiene y elimina todos los contenedores, redes y volúmenes definidos en el archivo `docker-compose.yml`. Es la forma limpia de apagar la aplicación.

## Fase 3 Comunicación entre Microservicios

En esta fase nos enfocaremos en  usar los mecanismos para gestionar la comunicación entre microservicios, empezaremos con las APIs REST y luego con la comunicación asíncrona.
### 1. APIs REST

Para este servicio necesitaremos 2 cosas:

- Una nueva carpeta  para nuestro segundo Microservicio que llamaremos  `servicio_compras`
- Actualizaremos nuestro proyecto de Flask (ejercicio_db), para que funcione como un servicio  de productos y exponga una API REST.

En la carpeta del proyecto  que contiene a proyecto `ejercicio_db` vamos a crear otra carpeta esta estará al mismo nivel de `ejercicio_db` se llamara como lo indicamos anteriormente `servicio_compras`

![[estructura de microservicios.png]]

en la carpeta de `ejercicio_db`, están albergada la aplicación que simula una API, lo único que contiene es una array de objetos> si lo queremos ver es como la aplicación de backend que sirve mediante API los productos.

Ahora la carpeta `servicio_compras`, contiene por así decirlo nuestro frontend que muestra el consumo que provee este backend. 

Así puedo ver dos microservicios uno nuestro backend sirviendo una base de datos y el otro microservicio se encarga de renderizar el consumo de esa API.

El archivo `docker-compose.yml`, en esta caso va a conectar 2 servicios(microservicios) de la misma categoría, o sea servicios web. En docker el primer servicio se llamara **productos**, que es el que contiene la carpera `ejercicio_db` y el segundo servicio se llamara **compras**, que es el que contiene la carpeta `servicio_compras`, veamos la estructura del archivo `docker-compose.yml`

![[docker-compose para unir dos servicios web.png]]

> Nótese que dejamos la instrucción `depend_on` al final del archivo ya que siempre hay una relación de dependencia. En este caso dependemos de **Productos** que es nuestra API, para poder ver el catalogo de compra, por eso dependemos de este servicio.

### 2. La comunicación Asíncrona con Colas de Mensajes

Debemos recordar que es síncrono y asíncrono:

- Las tareas síncronas son las que se ejecutan una detrás de otra, hasta que no termina la primera no empieza la segunda y así sucesivamente.
- Las tareas asíncronas trabajan de manera paralela y no son bloqueantes.

**La comunicación síncrona** es como cuando hacemos una llamada para proceder, si nadie nos contesta no podremos desarrollar la tarea.

Por otro lado **la comunicación asíncrona**, es como un correo electrónico: el emisor envía el mensaje y sigue con su vida. No necesita espera a que alguien le conteste inmediatamente. el receptor podrá actuar sobre el mensaje cuando le sea pertinente.

En el mundo de los microservicios la comunicación asíncrona se logra con sistemas de mensajería o colas de mensajes (como RabbitMQ o Apache Kafka)

**¿Por qué es útil?**

- **Tolerancia a fallos:** Si un servicio está caído, los mensajes simplemente esperan en la cola. Cuando el servicio se recupera, procesa los mensajes acumulados.
    
- **Desacoplamiento:** Los servicios no necesitan saber nada el uno del otro. Solo necesitan saber cómo enviar y recibir mensajes de la cola.
    
- **Escalabilidad:** Puedes añadir más "trabajadores" que lean los mensajes de la cola cuando el tráfico aumenta.
#### Siguiente Ejercicio: Colas de Mensajes

Para entenderlo de forma práctica, vamos a modificar nuestro proyecto para usar una cola de mensajes.

- El **`servicio_compras`** ya no hará una llamada directa al `servicio_productos`.
    
- En su lugar, agregaremos un tercer servicio: **`rabbitmq`**.
    
- Cuando alguien visite la página del `servicio_compras`, este servicio enviará un mensaje a la cola de RabbitMQ.
    
- Crearemos un cuarto servicio llamado **`procesador_compras`**, que leerá los mensajes de la cola y actuará sobre ellos (por ejemplo, guardando la compra en una base de datos).
#### Desarrollo del Ejercicio

1. Lo primero es crear un nuevo servicio en nuestro docker compose que sera el centralizador de la comunicación asíncrona entre contenedores  y presupuesto los microservicios de productos y compras.

```docker
rabbitmq:
	image: rabbitmq:3-management
	ports:
		- "5672":"5672"
		- "15672":"15672"
	restart: always
```
>Este es el nuevo servicio que agregaremos al archivo del docker-compose.yml.

![[agregamos servicio de comunicacion asincrona.png]]
> Así queda hasta ahora nuestros servicios en el `docker-compose.yml

Ahora, con este archivo, tenemos una arquitectura de tres servicios:

1. **`productos`**: Un microservicio que expone una API REST.
    
2. **`compras`**: Un microservicio que consume esa API.
    
3. **`rabbitmq`**: Un broker de mensajes que nos permitirá implementar la comunicación asíncrona.


